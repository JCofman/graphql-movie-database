type Query @cacheControl(maxAge: 10000) {
  """
  This query searches all database models simultaneously, via the
  `/search/multi` endpoint. The results will be a list of mixed types
  that can include Movie | Show | Person | Company.

  If you want to search for a specific type of object like movies or shows,
  use the multi-item query for that object, ie `movies` | `people`
  """
  search(query: String!, page: Int = 1): SearchResponse
  """
  Search the database for people that match a given search query.
  """
  people(query: String!, page: Int = 1): PersonList
  """
  Search the database for companies that match a given search query.
  """
  companies(query: String!, page: Int = 1): CompanyList
  """
  Get detailed information about a specific movie.
  """
  Movie(id: ID!): Movie
  """
  Get detailed information about a specific TV show.
  """
  Show(id: ID!): Show
  """
  Get the TV season details by id.
  """
  Season(showId: ID, seasonNumber: Int): Season
  """
  Get the TV episode details by id.
  """
  Episode(showId: ID, seasonNumber: Int, episodeNumber: Int): Episode
  """
  Get details information about a specific person.
  """
  Person(id: ID!): Person
  """
  Get the details about a production company.
  """
  Company(id: ID!): Company
  """
  Get the system configuration details from TMDB.
  """
  Configuration: Configuration
}

"""
The field containing query meta data.
@todo need to do some more research on best/practices
response types. Another pattern i have seen is to have two
queries, ie allPosts() and _allPostsMeta
"""
type QueryMeta @cacheControl(maxAge: 10000) {
  totalPages: Int
  totalResults: Int
  page: Int
}

type PersonList @cacheControl(maxAge: 10000) {
  meta: QueryMeta
  results: [Person]
}
type CompanyList @cacheControl(maxAge: 10000) {
  meta: QueryMeta
  results: [Company]
}
type SearchResponse @cacheControl(maxAge: 10000) {
  meta: QueryMeta
  results: [SearchResult]
}

union SearchResult = Person | Movie | Show | Company
